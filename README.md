# PKI Simulation Project
This project simulates a basic Public Key Infrastructure (PKI) system with two main components: Registration Authority (RA) and Certificate Authority (CA). The RA collects public key certificate (PKC) requests from end users and forwards them to the CA for approval and certificate generation. The CA generates, verifies, and returns the PKC based on the requests.

The project is built using Flask for Python, with separate applications for the RA and CA servers.

# Setting up the Project
### Prerequisites
- Python 3.x
- Flask
- `requests` library (for testing via Python)
- `curl` (for testing via bash)

### Setup Steps
1. **Clone the repository:**
    ```bash
    git clone https://github.com/your-repo/pki-simulation.git
    cd pki-simulation
    ```

2. **Install dependencies:**
    For both RA and CA servers, install the required Python libraries:
    ```bash
    pip install -r requirements.txt
    ```
    - Flask for web server functionality
    - requests for API testing

3. **Run the CA and RA Servers:**
    - Start the CA Server (Certificate Authority):
        ```bash
        cd ca_server
        python ca_app.py
        ```
    - Start the RA Server (Registration Authority):
        ```bash
        cd ra_server
        python ra_app.py
        ```
    - Both servers will start locally:
        - CA server on http://localhost:5001
        - RA server on http://localhost:5000

4. **Run the Test Script (Optional):**
    - You can test the complete PKI request and validation process by running the `verify-pkc.sh` or `get-pkc.sh` script in the root directory of the project. This script uses curl to interact with the RA and CA servers.
    
    To make it executable:
    ```bash
    chmod +x verify-pkc.sh
    ./verfiy-pkc.sh
    ```

    ```bash
    chmod +x get-pkc.sh
    ./get-pkc.sh
    ```

# Endpoints and Their Workings
## RA Server (http://localhost:5000)
The RA (Registration Authority) acts as an intermediary between the end-user and the CA. It verifies requests and forwards them to the CA for certificate generation.

- **POST** `/ra/request_certificate`:

    **Purpose:** End-users request a certificate by sending their public key and identifier to the RA.

    **Request Body:**

    ```json
    {
    "public_key": "user_public_key_1234",
    "identifier": "user@example.com"
    }
    ```
    **Response:**

    ```json
    {
    "status": "request_sent",
    "message": "Request sent to CA."
    }
    ```
    **Description:** The RA receives the request from the end-user and forwards it to the CA for approval and certificate generation.

- **POST** `/ra/verify_certificate` (Optional):

    **Purpose:** RA verifies the certificate generated by the CA for a given public key (used by end-users to validate a certificate directly).

    **Request Body:**

    ```json
    {
    "public_key": "user_public_key_1234"
    }
    ```
    **Response** (if certificate is valid):
    ```json
    {
    "status": "valid",
    "certificate": {
        "public_key": "user_public_key_1234",
        "identifier": "user@example.com",
        "issued_by": "CA",
        "issued_at": 1600000000,
        "certificate_id": "user@example.com-1600000000"
      }
    }
    ```

## CA Server (http://localhost:5001)
The CA (Certificate Authority) is responsible for generating and signing certificates. It also verifies certificates upon request.

- **POST** `/ca/verify_certificate`:

    **Purpose:** CA verifies the certificate by checking if the certificate exists and is valid. The public key sent in the request is matched against the certificates.

    **Request Body:**

    ```json
    {
    "public_key": "user_public_key_1234"
    }
    ```
    **Response:**

    ```json
    {
    "status": "valid",
    "certificate": {
        "public_key": "user_public_key_1234",
        "identifier": "user@example.com",
        "issued_by": "CA",
        "issued_at": 1600000000,
        "certificate_id": "user@example.com-1600000000"
      }
    }
    ```
    **Description:** The CA verifies whether the public key corresponds to a valid certificate and returns the details of the certificate (if valid).

- **POST** `/ca/approve_request/<request_id>`:

    **Purpose:** The CA approves a request for certificate generation, signs the public key, and issues the certificate to the end-user.

    **Request Body** (Not required, action is automatic based on request):

    ```json
    {
    "status": "approved",
    "certificate": {
        "public_key": "user_public_key_1234",
        "identifier": "user@example.com",
        "issued_by": "CA",
        "issued_at": 1600000000,
        "certificate_id": "user@example.com-1600000000"
      }
    }
    ```
    **Response:**
    ```json
    {
    "status": "certificate_issued",
    "message": "Certificate has been issued to the end-user."
    }
    ```
    **Description:** The CA approves certificate generation for a valid request, signs the public key, and returns the certificate to the RA (or directly to the end-user).


# Test Scenarios
## Scenario 1: Request to Generate a PKC (Public Key Certificate)
1. End-User sends request to RA to generate a PKC.

    **Request:**
    ```bash
    curl -X POST http://localhost:5000/ra/request_certificate \
        -H "Content-Type: application/json" \
        -d '{
            "public_key": "user_public_key_1234",
            "identifier": "user@example.com"
            }'
    ```
    **Expected RA Response:**
    ```json
    {
    "status": "request_sent",
    "message": "Request sent to CA."
    }
    ```

2. **RA forwards request to CA (This happens automatically in the RA backend).**

3. **CA generates the certificate and returns it to the RA.**
    Request to verify certificate (directly from the end-user or RA to CA):

    ```bash
    curl -X POST http://localhost:5001/ca/verify_certificate \
        -H "Content-Type: application/json" \
        -d '{
            "public_key": "user_public_key_1234"
            }'
    ```
    **Expected CA Response:**
    ```json
    {
    "status": "valid",
    "certificate": {
        "public_key": "user_public_key_1234",
        "identifier": "user@example.com",
        "issued_by": "CA",
        "issued_at": 1600000000,
        "certificate_id": "user@example.com-1600000000"
      }
    }
    ```

## Scenario 2: Verify a PKC
1. **End-User or RA sends a request to the CA to verify the PKC**.

    **Request:**
    ```bash
    curl -X POST http://localhost:5001/ca/verify_certificate \
        -H "Content-Type: application/json" \
        -d '{
            "public_key": "user_public_key_1234"
            }'
    ```
    **Expected Response:**

    ```json
    {
    "status": "valid",
    "certificate": {
        "public_key": "user_public_key_1234",
        "identifier": "user@example.com",
        "issued_by": "CA",
        "issued_at": 1600000000,
        "certificate_id": "user@example.com-1600000000"
      }
    }
    ```

2. **If the certificate is invalid or revoked, the CA will return:**

    ```json
    {
      "status": "invalid",
      "message": "Certificate not found."
    }
    ```

<br/>

# Conclusion
This project simulates the workflow of generating, issuing, and verifying Public Key Certificates (PKC) in a simple PKI system. The **RA Server** handles the collection and forwarding of requests, while the **CA Server** is responsible for certificate issuance and validation.

## Additional Notes:
- **Security**: In a real-world scenario, you'd want to implement secure communication (e.g., HTTPS) and handle private keys securely.

- **Extensions**: This basic simulation can be extended with features like Certificate Revocation Lists (CRLs), certificate expiration, etc.